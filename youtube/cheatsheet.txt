curl -X GET localhost:8080/v1/api/channel/UCZN6X0ldwi-2W4TV-ab5M_g/insights | python3 -m json.tool
curl -X GET localhost:8080/v1/api/channel/UCZN6X0ldwi-2W4TV-ab5M_g/videos | python3 -m json.tool
curl -X GET localhost:8080/v1/api/video/vrOttI2cgAM/insights | python3 -m json.tool
curl -X GET localhost:8080/v1/api/video/vrOttI2cgAM/sentiments | python3 -m json.tool

1) Money Purse Channel id: UChBT5TlUeG68PKvJSg6MkqQ
2) Akshat Shrivastava: UCqW8jxh4tH1Z1sWPbkGWL4g
3) Thulasi Chandu: UCZN6X0ldwi-2W4TV-ab5M_g
4) Sahil Bhadviya: UCdc6ObxhdQ8eZIFquU2xolA
5) Moneyvest: UCf3g0uNBn6wPpgrTK_AbJrQ
6) First Post: UCz8QaiQxApLq8sLNcszYyJw


settting up react-app: npx create-react-app <myAPP>
To start UI app: npm start
For production app: run "npm run build" in the react-app dir.

On EC2:
install nginx: sudo yum install -y nginx
copy react-app to EC2 instance: scp -i ~/.ssh/id_rsa -r build ec2-user@IP:~/
copy to nginx root dir: sudo mv build /usr/share/nginx/html
debug : sudo lsof -i :80 or sudo lsof -i :8080


For older mac OS (Mojave 10.14.6) install Docker Desktop 4.9.1 from https://docs.docker.com/desktop/release-notes/

docker build -t my-node-app .
docker run -p 3000:3000 my-node-app

If you are running the Go server on the same EC2 instance as the React app, localhost refers to the EC2 instance itself, not the clientâ€™s browser. Instead, you should use the server's public DNS or IP address for API requests.


Destroy/Apply specific resource using terraform example:
 - terraform state list
 - terraform destroy -target=aws_vpc_security_group_egress_rule.allow_8080
 - terraform apply -target=aws_vpc_security_group_ingress_rule.allow_8080


golang server to bind :8080:

https://stackoverflow.com/questions/73830150/cannot-assign-requested-address-in-aws-java-server-socket

In general you would not bind to the IP address directly. You would instead bind to all interfaces by not specifying a host. In this way you will respond to any incoming connections to the specified port. If I look at a Wildfly server I have running with Apache HTTPD in front of it I get:

$ netstat -na | grep LIST
tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN
tcp6       0      0 :::80                   :::*                    LISTEN
In my case the Wildfly server is using IPv4 and Apache is using IPv6. But they are both listening on what is, for IPv4, 0.0.0.0. The O/S takes care of the external interface to internal address mapping.
